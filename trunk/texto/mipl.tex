% ----------------------------------------------------------------------- %
% Arquivo: mipl.tex
% ----------------------------------------------------------------------- %
\chapter{Implementação do HMIPv6 baseando-se no projeto MIPL}

\section{Implementações existentes para Linux dos protocolos de Mobilidade}

O projeto \textit{Mobile IPv6 for Linux} (MIPL) \cite{CitarMIPL} é uma
implementação de suporte a mobilidade no IPv6 (RFC 3775), desenvolvida na
Universidade Tecnólogica de Helsinki . O codigo foi desenvolvido acompanhando os
\textit{drafts} da RFC e as versões do \textit{kernel linux}. No início do
desenvolvimento, a versão do kernel utilizada foi a 2.3.59 e o \textit{draft} 8,
porém, devido as substânciais mudanças na especificação do MIPv6, os ge
stores do projeto decidiram dividir o código fonte uma parte em espaço de kernel
e outra em espaço de usuário. A última versão foi o MIPL 1.1 que trabalhava com
a versão 2.4.26 do \textit{kernel linux}.

Mais adiante, iniciou-se o desenvolvimento do MIPL2 pela Universidade de Helsink
juntamente com o projeto USAGI \cite{CitarUsagi}. Nesta nova versão houveram
mudanças significativas: o código foi praticamente todo reescrito e muitas
funcionalidades foram adicionadas em espaço de usuário. Um \textit{daemon}
passou a controlar a sinalização e a detecção de movimento. A tarefa do
\textit{kernel} passou a ser apenas uma camada de suporte ao MIPv6.

O MIPL2 passou a suportar as últimas especificações do MIPv6 e passou a utilizar
\textit{framework} XFRM para o suporte a IPSec. É interessante observar também
que, a partir das últimas versões do kernel do linux, o suporte ao MIPv6 já faz
parte da linha principal de desenvolvimento, não sendo mais necessário aplicar
\textit{patchs}.

No que se refere ao HMIPv6, uma implementação foi proposta pela Universidade
de Monash, baseando-se no MIPL 0.94 e na versão 2.4 do \textit{kernel linux}.
Também foram realizadas alterações no RADVD 0.7.2 para este divulgar mensagens
de MAP. Neste momento, o projeto está parado e não atende mais as necessidades
deste trabalho, pois, ocorreram mudanças significativas no desenvolvimento do
MIPL. Atualmente a grande maioria dos sistemas já utilizam a série 2.6 do
\textit{kernel}, então pode-se concluir que não há nenhuma implementação
aberta e recente do HMIPv6.

O trabalho propõe-se, então desenvolver uma  implementação experimental
atualizada do HMIPv6, baseando-se na última versão estável do projeto MIPL
e utilizando a versão 0.7.2 do RADVD alterado pelo projeto da Universidade de
Monash.

\section{Estudo do código do projeto MIPL}
Com fins de gerar uma versão do HMIPv6 a partir do projeto MIP, iniciou-se
um estudo aprofundado do código fonte do MIPL. O estudo do código do
MIPL2 foi realizado na sua última versão estável, anunciada pelo projeto USAGI
como umip-0.4. O MIPL é um projeto de codigo aberto sobre a licença GPL versão
2, escrito na linguagem de programação C.

O programa é executado na forma de um \textit{daemon} chamado de \textit{mip6d},
ou seja, um processo executado no segundo plano e que não está associado a um
terminal controlador \ref{stevens}. Este mesmo \textit{daemon} desempenha o
papel de nó móvel, de agente domiciliar e de nó correspondente. A sua função é
definida em um arquivo de configuração, sendo que todos os nós são em pontencial
um nó correspondente.

O foco principal do estudo foi na parte responsável pelo
funcionamento do nó móvel, pois as principais mudanças do MIPv6 para o HMIPv6 é
a funcionalidade deste nó. O agente MAP possui, basicamente, o mesmo
comportamento de um agente domiciliar, a não ser pelo de fato de possuir uma
rede com prefixo a partir do qual serão criados RCoAs. Além do que, todo o
projeto é de alta complexidade, envolvendo o uso de várias bibliotecas, o que
demandaria um tempo grande de estudo. É bom lembrar também que, com fins de
delimitar o escopo do trabalho, foram desconsiderados todos os mecanismos de
segurança do HMIPv6.

\subsection{Interação entre o \textit{kernel} e o MIPL}
Geralmente tudo o que fizemos, enquanto trabalhamos em um sistema Linux, está
sendo executado em em espaço de usuário, por exemplo: um editor de texto, um
navegador, servidor X. Em contraste com isso, o \textit{kernel} executa as suas
tarefas em espaço de \textit{kernel}, com acesso à instruções privilegiadas,
total controle da memória e do sistema de interrupções. O principal motivo para
esta separação entre dados dos processos do usuário e do
\textit{kernel}, é evitar que um perturbe o outro, o que resultaria numa
diminuição do desempenho, problemas de segurança e instabilidades do sistema
\ref{spaces}.

Os motivos levantados acima foram os que levaram os desenvolvedores a passarem a
maioria da implementação do protocolo MIPv6 para espaço de usuário, o que torna
desenvolvimento mais fácil, seguro e independente de versão de \textit{kernel}.
Porém o MIPL precisa de uma interface para a troca de informações entre o
\textit{kernel} e espaço de usuário. A troca de informação do entre
\textit{kernel} e o espaço de usuário é realizada através do
\textit{netlink}. O \textit{netlink} consiste em uma extensão da interface de
soquetes padrão, que proporciona uma comunicação bidirecional entre
\textit{kernel} e o espaço de usuário. O soquete netlink usa endereços da
familia AF\_NETLINK, comparado ao AF\_INET usado pelos soquetes TCP/IP
\ref{netlink}.

O soquete \textit{netlink} é a forma utilizada pelo MIPL para:
\begin{itemize}
 \item acessar as informações do MIPv6 no \textit{kernel};
 \item alterar endereços IP's;
 \item manipular tabelas de roteamento e regras das políticas de uso destas
tabelas;
 \item criar túneis.
\end{itemize}

Os soquetes brutos também são utilizados pelo MIPL para permitir a leitura e
envio de pacotes puramente IP sem a interferência do \textit{kernel}\ref{raw}.
Em condições normais quando o kernel não entende o campo de protocolo do
datagrama IP, como por exemplo, os que possuim cabeçalho de mobilidade, eles são
passados diretamente para um soquete bruto. O único processamento feito pelo
\textit{kernel} é a verificação mínima de alguns campos de cabeçalho IP.

Esta capacidade permite que tais pacotes possam ser tratados por aplicações
independentes de inserção de códigos especiais em \textit{kernel}, neste caso o
\textit{daemon} MIPL.

\subsection{\textit{Threads} importantes do MIPL}
No seu funcionamento, o \textit{daemon} do MIPL necessita realizar várias
tarefas, por exemplo, interagir com o \textit{kernel}. Para realizar as várias
funções que permitem o funcionamento do protocolo MIPv6, o programa utiliza a
técnica de \textit{Multithreading}. A seguir são listadas \textit{threads} que
executam no \textit{daemon} e a figura \ref{f_mipl_kernel_blocks} mostra a forma
que algumas delas se relacionam com o \textit{kernel}.

\subsubsection{\textit{runner}}
Durante a sua execução, o \textit{mip6d} necessita agendar tarefas para serem
executadas. Por exemplo, caso o tempo de vida de um endereço expirar ele precisa
ser removido, para isso, o \textit{daemon} cria uma tarefa que remove o
endereço da interface, e a insere em uma fila global de tarefas.

Para inserir tarefas na fila o \textit{daemon} utiliza a função
\textit{add\_task\_abs}, passando como parâmetro:
\begin{itemize}
 \item o tempo em milisegundos para a execução da tarefa;
 \item ponteiro para função que deve ser chamada quando o tempo da tarefa
expirar.
\end{itemize}

\begin{figure}[!htpb]
	\centering
	\includegraphics[scale=.8]{figs/task}
	\caption{Fila de tarefas agendadas do MIPL}
	\label{f_mipl_tasks}
\end{figure}

A \textit{thread runner}, fica percorrendo a fila de tarefas(ver figura
\ref{f_mipl_tasks}) e quando o tempo da tarefa expira, executa uma função
associada, previamente registrada.

\subsubsection{\textit{icmp6\_listen}}
O MIPL cria uma \textit{thread} para escutar mensagens ICMPv6 e para isso cria
um soquete bruto. Porém, há muitas mensagens ICMPv6, por isso, para reduzir o
número de pacotes passados do \textit{kernel} para a aplicação, é fornecido um
filtro especifico pela aplicação. Na tabela \ref{t_mipl_icmp} é possível
observar as mensagens ICMPv6 que serão tratadas pelo MIPL.

\begin{table}[!htpb]
\centering
\begin{small}
  \setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|c|c|c|}\hline
\raisebox{1.5ex}{Função mip6d} & \raisebox{1.5ex}{Mensagem Filtrada} &
\raisebox{1.5ex}{Função}\\ \hline
Nó Móvel & ND\_ROUTER\_ADVERT & Anúncio de roteadores  \\ 
	 & ND\_NEIGHBOR\_ADVERT & Anúncio de vizinhança \\ 
	 & MIP\_HA\_DISCOVERY\_REPLY & Resposta de descoberta de agente
domiciliar \\
	 & ICMP6\_PARAM\_PROB & askdfj;al \\
	 & ICMP6\_DST\_UNREACH & Destino inalcançável \\ \hline
Agente Domiciliar & MIP\_PREFIX\_SOLICIT & Solicitação de prefixo \\
		  & MIP\_HA\_DISCOVERY\_REQUEST & Descoberta de agente
domiciliar \\
		  & ND\_ROUTER\_ADVERT & Anúncio de roteadores \\
		  & ICMP6\_DST\_UNREACH & Destino inalcançável; \\ \hline
\end{tabular} 
\end{small}
\caption{Filtros para os pacotes ICMPv6 feitos pelo MIPL}
\label{t_mipl_icmp}
\end{table} 

Durante a execução do \textit{daemon} é feita a instalação de manipuladores, que
tratam as mensagens, em uma lista global. Ao receber uma das mensagens ICMPv6
filtradas, a \textit{thread} percorre a lista de manipuladores e chama a função
para tratar a mensagem.

\begin{figure}[!htpb]
	\centering
	\includegraphics[scale=.27]{figs/mipl_kernel_block}
	\caption{Interfaces utilizadas pelo MIPL para fazer a comunicação com o
kernel}
	\label{f_mipl_kernel_blocks}
\end{figure}

\subsubsection{\textit{mh\_listen}}
\textit{Thread} criada para escutar a chegada de pacotes IPv6 com cabeçalho de
mobilidade. O seu funcionamento é semelhante a \textit{thread icmp6\_listen}: ao
receber uma mensagem com o cabeçalho de mobilidade chama um manipulador,
previamente instalado em uma lista global, para tratar a mensagem.

\subsubsection{\textit{xfrm\_listen}}
O \textit{daemon} cria a \textit{thread xfrm\_listen} que escuta mensagens
\textit{netlink} do \textit{framework} XFRM. Um manipulador é instalado para
tratar essas mensagens. As mensagens são: XFRM_MSG_ACQUIRE e XFRM_MSG_REPORT.

\subsubsection{\textit{md\_nl\_listen}}
O \textit{mip6d} cria uma \textit{thread} para tratar mensagens \textit{netlink}
do tipo NETLINK\_ROUTE enviadas pelo \textit{kernel}. Esta \textit{thread} é
executada somente no nó móvel.

A \textit{thread} ao receber uma mensagem \textit{netlink}, chama o manipulador
instalado para tratá-la. As mensagens tratadas pelo manipulador são as que
informam:
\begin{itemize}
 \item a interface ou ligação: ligado ou desligado;
 \item as mudanças no estado da alcançabilidade do roteador padrão;
 \item os \textit{Care-of-address} novos ou removidos.
\end{itemize}

\subsubsection{\textit{vt\_server\_recv}}
É possivel habilitar em tempo de compilação um terminal virtual. O terminal
virtual permite que os usuários se conectem ao \textit{daemon}, via protocolo
\textit{telnet}, para obter informações sobre o MIPv6, por exemplo:
\begin{itemize}
 \item O tempo de vida do prefixo do agente domiciliar;
 \item O estado do \textit{Binding cache};
 \item A Lista de \textit{Bindig Updates}.
\end{itemize}

A \textit{thread} \textit{vt\_server\_recv} é criada para responder as conexões
para o terminal virtual, que é executado na porta 7777.

\subsubsection{\textit{sigh}}
O \textit{mip6d} implementa uma \textit{thread} que é responsável por fazer o
tratamento de alguns sinais do sistema. Os sinais que passam a ser tratados pela
aplicação são:
\begin{description}
 \item[SIGHUP:] Significa o reinicio do programa, o \textit{daemon} ao receber
esse sinal executa a função \textit{reinit};
\item[SIGINT:] Causa a interrupção do programa, em termos práticos é o sinal
recebido quando se pressiona as teclas \textit{Control+C}. Neste caso ao receber
este sinal o \textit{daemon} chama a função \textit{terminate};
\item[SIGTERM:] Solicitação de término do programa, neste caso o \textit{daemon}
também chama a função \textit{terminate}.
 \end{description}

É de extrema importância o tratamento destes sinais pelo \textit{daemon}, pois
ao finalizar o programa é preciso deletar eventuais endereços IP's, túneis,
tabelas de roteamento.

\subsection{Detecção de Movimento}

\subsection{Processo de Registro}

\section{Alterações propostas para o MIPL}
Após uma análise dos dois protocolos e um estudo prévio do codigo fonte do MIPL,
o presente trabalho se propõe a sugerir algumas alterações no MIPL para este
então passar trabalhar no modelo hierárquico...