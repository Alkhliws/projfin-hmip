% ----------------------------------------------------------------------- %
% Arquivo: mipl.tex
% ----------------------------------------------------------------------- %
\chapter{Implementação do HMIPv6 baseando-se no projeto MIPL}

\section{Implementações existentes para Linux dos protocolos de Mobilidade}

O projeto \textit{Mobile IPv6 for Linux} (MIPL) \cite{CitarMIPL} é uma
implementação de suporte a mobilidade no IPv6 (RFC 3775), desenvolvida na
Universidade Tecnólogica de Helsinki . O codigo foi desenvolvido acompanhando os
\textit{drafts} da RFC e as versões do \textit{kernel linux}. No início do
desenvolvimento, a versão do kernel utilizada foi a 2.3.59 e o \textit{draft} 8,
porém, devido as substânciais mudanças na especificação do MIPv6, os gestores 
do projeto decidiram dividir o código fonte uma parte em espaço de kernel
e outra em espaço de usuário. A última versão foi o MIPL 1.1 que trabalhava com
a versão 2.4.26 do \textit{kernel linux}.

Mais adiante, iniciou-se o desenvolvimento do MIPL2 pela Universidade de Helsink
juntamente com o projeto USAGI \cite{CitarUsagi}. Nesta nova versão houveram
mudanças significativas: o código foi praticamente todo reescrito e muitas
funcionalidades foram adicionadas em espaço de usuário. Um \textit{daemon}
passou a controlar a sinalização e a detecção de movimento. A tarefa do
\textit{kernel} passou a ser apenas uma camada de suporte ao MIPv6.

O MIPL2 passou a suportar as últimas especificações do MIPv6 e passou a utilizar
\textit{framework} XFRM para o suporte a IPSec. É interessante observar também
que, a partir das últimas versões do kernel do linux, o suporte ao MIPv6 já faz
parte da linha principal de desenvolvimento, não sendo mais necessário aplicar
\textit{patchs}.

No que se refere ao HMIPv6, uma implementação foi proposta pela Universidade
de Monash, baseando-se no MIPL 0.94 e na versão 2.4 do \textit{kernel linux}.
Também foram realizadas alterações no RADVD 0.7.2 para este divulgar mensagens
de MAP. Neste momento, o projeto está parado e não atende mais as necessidades
deste trabalho, pois, ocorreram mudanças significativas no desenvolvimento do
MIPL. Atualmente a grande maioria dos sistemas já utilizam a série 2.6 do
\textit{kernel}, então pode-se concluir que não há nenhuma implementação
aberta e recente do HMIPv6.

O trabalho propõe-se, então desenvolver uma  implementação experimental
atualizada do HMIPv6, baseando-se na última versão estável do projeto MIPL
e utilizando a versão 0.7.2 do RADVD alterado pelo projeto da Universidade de
Monash.

\section{Estudo do código do projeto MIPL}
Com fins de gerar uma versão do HMIPv6 a partir do projeto MIP, iniciou-se
um estudo aprofundado do código fonte do MIPL. O estudo do código do
MIPL2 foi realizado na sua última versão estável, anunciada pelo projeto USAGI
como umip-0.4. O MIPL é um projeto de codigo aberto sobre a licença GPL versão
2, escrito na linguagem de programação C.

O programa é executado na forma de um \textit{daemon} chamado de \textit{mip6d},
ou seja, um processo executado no segundo plano e que não está associado a um
terminal controlador \ref{stevens}. Este mesmo \textit{daemon} desempenha o
papel de nó móvel, de agente domiciliar e de nó correspondente. A sua função é
definida em um arquivo de configuração, sendo que todos os nós são em pontencial
um nó correspondente.

O foco principal do estudo foi na parte responsável pelo
funcionamento do nó móvel, pois as principais mudanças do MIPv6 para o HMIPv6 é
a funcionalidade deste nó. O agente MAP possui, basicamente, o mesmo
comportamento de um agente domiciliar, a não ser pelo de fato de possuir uma
rede com prefixo a partir do qual serão criados RCoAs. Além do que, todo o
projeto é de alta complexidade, envolvendo o uso de várias bibliotecas, o que
demandaria um tempo grande de estudo. É bom lembrar também que, com fins de
delimitar o escopo do trabalho, foram desconsiderados todos os mecanismos de
segurança do HMIPv6.

\subsection{Interação entre o \textit{kernel} e o MIPL}
Geralmente tudo o que fizemos, enquanto trabalhamos em um sistema Linux, está
sendo executado em em espaço de usuário, por exemplo: um editor de texto, um
navegador, servidor X. Em contraste com isso, o \textit{kernel} executa as suas
tarefas em espaço de \textit{kernel}, com acesso à instruções privilegiadas,
total controle da memória e do sistema de interrupções. O principal motivo para
esta separação entre dados dos processos do usuário e do
\textit{kernel}, é evitar que um perturbe o outro, o que resultaria numa
diminuição do desempenho, problemas de segurança e instabilidades do sistema
\ref{spaces}.

Os motivos levantados acima foram os que levaram os desenvolvedores a passarem a
maioria da implementação do protocolo MIPv6 para espaço de usuário, o que torna
desenvolvimento mais fácil, seguro e independente de versão de \textit{kernel}.
Porém o MIPL precisa de uma interface para a troca de informações entre o
\textit{kernel} e espaço de usuário. A troca de informação do entre
\textit{kernel} e o espaço de usuário é realizada através do
\textit{netlink}. O \textit{netlink} consiste em uma extensão da interface de
soquetes padrão, que proporciona uma comunicação bidirecional entre
\textit{kernel} e o espaço de usuário. O soquete \textit{netlink} usa endereços
da família AF\_NETLINK, comparado ao AF\_INET usado pelos soquetes TCP/IP
\ref{netlink}.

O soquete \textit{netlink} é a forma utilizada pelo MIPL para:
\begin{itemize}
 \item acessar as informações do MIPv6 no \textit{kernel};
 \item alterar endereços IP's;
 \item manipular tabelas de roteamento e regras das políticas de uso destas
tabelas;
 \item criar túneis.
\end{itemize}

Os soquetes brutos também são utilizados pelo MIPL para permitir a leitura e
envio de pacotes puramente IP sem a interferência do \textit{kernel}\ref{raw}.
Em condições normais quando o kernel não entende o campo de protocolo do
datagrama IP, como por exemplo, os que possuim cabeçalho de mobilidade, eles são
passados diretamente para um soquete bruto. O único processamento feito pelo
\textit{kernel} é a verificação mínima de alguns campos de cabeçalho IP.

Esta capacidade permite que tais pacotes possam ser tratados por aplicações
independentes de inserção de códigos especiais em \textit{kernel}, neste caso o
\textit{daemon} MIPL.

\subsection{\textit{Threads} importantes do MIPL}
No seu funcionamento, o \textit{daemon} do MIPL necessita realizar várias
tarefas, por exemplo, interagir com o \textit{kernel}. Para realizar as várias
funções que permitem o funcionamento do protocolo MIPv6, o programa utiliza a
técnica de \textit{Multithreading}. A seguir são listadas \textit{threads} que
executam no \textit{daemon} e a figura \ref{f_mipl_kernel_blocks} mostra a forma
que algumas delas se relacionam com o \textit{kernel}.

\subsubsection{\textit{runner}}
Durante a sua execução, o \textit{mip6d} necessita agendar tarefas para serem
executadas. Por exemplo, caso o tempo de vida de um endereço expirar ele precisa
ser removido, para isso, o \textit{daemon} cria uma tarefa que remove o
endereço da interface, e a insere em uma fila global de tarefas.

Para inserir tarefas na fila o \textit{daemon} utiliza a função
\textit{add\_task\_abs}, passando como parâmetro:
\begin{itemize}
 \item o tempo em milisegundos para a execução da tarefa;
 \item ponteiro para função que deve ser chamada quando o tempo da tarefa
expirar.
\end{itemize}

\begin{figure}[!htpb]
	\centering
	\includegraphics[scale=.8]{figs/task}
	\caption{Fila de tarefas agendadas do MIPL}
	\label{f_mipl_tasks}
\end{figure}

A \textit{thread runner}, fica percorrendo a fila de tarefas(ver figura
\ref{f_mipl_tasks}) e quando o tempo da tarefa expira, executa uma função
associada, previamente registrada.

\subsubsection{\textit{icmp6\_listen}}
O MIPL cria uma \textit{thread} para escutar mensagens ICMPv6 e para isso cria
um soquete bruto. Porém, há muitas mensagens ICMPv6, por isso, para reduzir o
número de pacotes passados do \textit{kernel} para a aplicação, é fornecido um
filtro especifico pela aplicação. Na tabela \ref{t_mipl_icmp} é possível
observar as mensagens ICMPv6 que serão tratadas pelo MIPL.

\begin{table}[!htpb]
\centering
\begin{small}
  \setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|c|c|c|}\hline
\raisebox{1.5ex}{Função mip6d} & \raisebox{1.5ex}{Mensagem Filtrada} &
\raisebox{1.5ex}{Função}\\ \hline
Nó Móvel & ND\_ROUTER\_ADVERT & Anúncio de roteadores  \\ 
	 & ND\_NEIGHBOR\_ADVERT & Anúncio de vizinhança \\ 
	 & MIP\_HA\_DISCOVERY\_REPLY & Resposta de descoberta de agente
domiciliar \\
	 & ICMP6\_PARAM\_PROB & askdfj;al \\
	 & ICMP6\_DST\_UNREACH & Destino inalcançável \\ \hline
Agente Domiciliar & MIP\_PREFIX\_SOLICIT & Solicitação de prefixo \\
		  & MIP\_HA\_DISCOVERY\_REQUEST & Descoberta de agente
domiciliar \\
		  & ND\_ROUTER\_ADVERT & Anúncio de roteadores \\
		  & ICMP6\_DST\_UNREACH & Destino inalcançável; \\ \hline
\end{tabular} 
\end{small}
\caption{Filtros para os pacotes ICMPv6 feitos pelo MIPL}
\label{t_mipl_icmp}
\end{table} 

Durante a execução do \textit{daemon} é feita a instalação de manipuladores, que
tratam as mensagens, em uma lista global. Ao receber uma das mensagens ICMPv6
filtradas, a \textit{thread} percorre a lista de manipuladores e chama a função
para tratar a mensagem.

\begin{figure}[!htpb]
	\centering
	\includegraphics[scale=.27]{figs/mipl_kernel_block}
	\caption{Interfaces utilizadas pelo MIPL para fazer a comunicação com o
kernel\cite{CitarFigura}}
	\label{f_mipl_kernel_blocks}
\end{figure}

\subsubsection{\textit{mh\_listen}}
\textit{Thread} criada para escutar a chegada de pacotes IPv6 com cabeçalho de
mobilidade. O seu funcionamento é semelhante a \textit{thread icmp6\_listen}: ao
receber uma mensagem com o cabeçalho de mobilidade chama um manipulador,
previamente instalado em uma lista global, para tratar a mensagem.

\subsubsection{\textit{xfrm\_listen}}
O \textit{daemon} cria a \textit{thread xfrm\_listen} que escuta mensagens
\textit{netlink} do \textit{framework} XFRM. Um manipulador é instalado para
tratar essas mensagens. As mensagens são: XFRM\_MSG\_ACQUIRE e
XFRM\_MSG\_REPORT.

\subsubsection{\textit{md\_nl\_listen}}
O \textit{mip6d} cria uma \textit{thread} para tratar mensagens \textit{netlink}
do tipo NETLINK\_ROUTE enviadas pelo \textit{kernel}. Esta \textit{thread} é
executada somente no nó móvel.

A \textit{thread} ao receber uma mensagem \textit{netlink}, chama o manipulador
instalado para tratá-la. As mensagens tratadas pelo manipulador são as que
informam:
\begin{itemize}
 \item a interface ou ligação: ligado ou desligado;
 \item as mudanças no estado da alcançabilidade do roteador padrão;
 \item os \textit{Care-of-address} novos ou removidos.
\end{itemize}

\subsubsection{\textit{vt\_server\_recv}}
É possivel habilitar em tempo de compilação um terminal virtual. O terminal
virtual permite que os usuários se conectem ao \textit{daemon}, via protocolo
\textit{telnet}, para obter informações sobre o MIPv6, por exemplo:
\begin{itemize}
 \item O tempo de vida do prefixo do agente domiciliar;
 \item O estado do \textit{Binding cache};
 \item A Lista de \textit{Bindig Updates}.
\end{itemize}

A \textit{thread} \textit{vt\_server\_recv} é criada para responder as conexões
para o terminal virtual, que é executado na porta 7777.

\subsubsection{\textit{sigh}}
O \textit{mip6d} implementa uma \textit{thread} que é responsável por fazer o
tratamento de alguns sinais do sistema. Os sinais que passam a ser tratados pela
aplicação são:
\begin{description}
 \item[SIGHUP:] Significa o reinicio do programa, o \textit{daemon} ao receber
esse sinal executa a função \textit{reinit};
\item[SIGINT:] Causa a interrupção do programa, em termos práticos é o sinal
recebido quando se pressiona as teclas \textit{Control+C}. Neste caso ao receber
este sinal o \textit{daemon} chama a função \textit{terminate};
\item[SIGTERM:] Solicitação de término do programa, neste caso o \textit{daemon}
também chama a função \textit{terminate}.
 \end{description}

É de extrema importância o tratamento destes sinais pelo \textit{daemon}, pois
ao finalizar o programa é preciso deletar eventuais endereços IP's, túneis,
tabelas de roteamento.

\subsection{Detecção de Movimento}
O algoritmo de detecção de movimento do MIPL é inteiramente baseado na escuta
das mensagens de anúncio de roteadores. O nó móvel está constantemente escutando
as mensagens de RA, sendo que o nó percebe o movimento quando:
\begin{itemize}
 \item o seu roteador padrão torne-se inalcançável; para tanto, o nó móvel de
tempos em tempos, verifica o roteador com um \textit{Neighbor Solicitation};
 \item passa a receber mensagens de outro roteador e para de escutar
mensagens do anterior.
\end{itemize}

Embora o MIPL seja uma extensão da pilha IPv6 padrão do \textit{Linux},
apresenta algumas características sobre administração de roteadores:
\begin{enumerate}
 \item O MIPL possui a sua própria lista de roteadores. Esta lista contém o 
atual roteador de acesso, bem como roteadores que não são atualmente
utilizados, mas com tempo de vida não expirados;
 \item o MIPL força atualizações na tabela de roteamento após receber um anúncio
de novo roteador, e apaga todas as informações de roteamento que não são do
prefixo atual.
\end{enumerate}
Devido a estas duas características, o MIPL sempe escolhe um novo roteador. Este
método de seleção agressiva de roteadores traz uma melhora na detecção de 
movimento, ou seja, no tempo de \textit{handover}.

\section{Alterações no MIPL para obter o HMIPv6}
A primeira implementação necessária foi dar suporte ao MIPL a leitura das
mensagens RA divulgadas pelos MAP's, pois são elas que permitem a criação do
endereço RCoA. No manipulador de mensagens RA foi adicionado o suporte para
a leitura da opção de MAP na mensagem RA. Foi criada uma estrutura de dados
para o MAP e funções para manipulação desta estrutura. Na estrutura de dados do
roteador foi adicionado uma lista de MAP's. A estrutura é mostrada a seguir.

\begin{lstlisting}
struct map_list_entry
{
    struct list_head list;
    struct timespec timestamp;
    struct tq_elem tqe;
    struct nd_opt_map map;
    struct in6_addr rcoa;
    int used;
};
\end{lstlisting}
A estrutura contêm:
\begin{itemize}
 \item os campos da opção de MAP da mensagem RA;
 \item tempo de vida do roteador que entregou a mensagem;
 \item endereço RCoA criado a partir do endereço do MAP;
 \item estrutura de dados que permite criar tarefas para serem agendadas;
\end{itemize}

No processamento da mensagem RA foram adicionados novos eventos de
movimento:\textbf{ME\_MAP\_NEW}, \textbf{ME\_MAP\_UPDATE} e
\textbf{ME\_MAP\_EXPIRED} Estes eventos tem a função de colher os
dados que serão utilizados no momento do registro e  manter os dados para o
funcionamento do protocolo.

Foi criada também uma estrutura de dados para o RCoA tendo sido adicionada na
estrutura do agente domiciliar. As informações contidas na estrutura serão
utilizadas no momento da formação das mensagens de BU e no controle do registro.

\begin{lstlisting}
struct rcoa_addr_info {
    struct mn_addr rcoa; /* Home address for MAP */
    uint8_t mlen;
    uint8_t map_reg_status;
    struct in6_addr map_prefix;
    struct in6_addr map_addr;
    int pend_ba;
    int site;
    int if_tunnel;
};
\end{lstlisting}

Outas implementações foram realizadas no nó móvel, quais sejam:
\begin {itemize}
 \item  foi acrescentado ao mecanismo de registro, um suporte ao envio do BU
para o MAP;
\item alteração da mensagem de BU para o agente domiciliar;
\item criação do túnel, com o MAP;
\item e modificação do túnel com o agente domiciliar.
\end {itemize}

Algo interessante de salientar é que toda a parte de tomada de decisão sobre o
movimento se manteve e as alterações atuam somente na forma do registro com
os agentes.

\subsection{Detalhes do funcionamento}
A seguir, uma descrição das implementações efetuadas no MIPL em um movimento
para um novo domínio:
\begin{enumerate}
 \item Ao receber uma mensagem RA de um novo roteador de acesso:
\begin{itemize}
 \item as opções de MAP são lidas;
 \item uma lista de MAP's é criada na estrutura do roteador.
\end{itemize}
 \item Um novo MAP dispara um evento de movimento do tipo \textbf{ME\_MAP\_NEW}
que:
\begin{itemize}
 \item faz escolha de um MAP na lista de roteadores, baseado na distância em
saltos do MAP;
 \item cria um túnel para o MAP;
 \item adiciona o RCoA na interface do túnel;
 \item define o RCoA na estrutura do agente domiciliar, utilizado no envio do
BU.
\end{itemize}
 \item o movimento é detectado, usando o código normal do MIPL. O registro
deve ser, então, realizado com os agentes:
\begin{itemize}
 \item enviado BU para o MAP com os campos:
\begin{itemize}
 \item Origem = RCoA
 \item Destino = endereço MAP
 \item Care-of-Adress = LCoA
\end{itemize}
 \item enviado BU para agente domiciliar com os campos:
 \begin{itemize}
  \item Origem = endereço domiciliar
  \item Destino = endereço agente domiciliar
  \item Care-of-Adress = RCoA
 \end{itemize}
\end{itemize}
 \item Após o envio dos BU's, os túneis devem ser modificados:
 \begin{itemize}
  \item Túnel entre nó móvel e MAP: o ponto final é a interface de rede.
  \item Túnel entre nó móvel e agente domiciliar: o ponto final é o túnel entre
nó móvel e MAP.
 \end{itemize}
 \item Periodicamente, com a chegada dos RA's, o evento de movimento
\textbf{ME\_MAP\_UDATE} é disparado e o tempo de vida do RCoA é atualizado.
\end{enumerate}

\subsection{Problemas conhecidos}
Considerando o caráter experimental do trabalho, a disponibilidade de tempo
para a sua execução e a alta
complexidade do código do MIPL, pode-se dizer que muito trabalho deve ainda ser
realizado para a obtenção de uma versão completa do HMIPv6. No que se refere a
implementação efetuada, alguns problemas podem, em particular, ser apontados:
\begin{itemize}
 \item ausência de suporte a otimização de rotas;
 \item ausência de suporte a segurança (IPSec);
 \item ausência de suporte ao HMIPv6 em arquivo de configuração, somente em
tempo de compilação;
 \item sem tarefas para deletar MAP's expirados;
 \item problema ao receber BA provindo do MAP, o que ocasiona problemas em
mobilidade em um mesmo domínio;
 \item problemas no retorno para rede domiciliar.
\end{itemize}
